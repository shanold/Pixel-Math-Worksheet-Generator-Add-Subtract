<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pixel Math Worksheet Generator</title>
<style>
  :root { --ui-bg:#111; --ui-fg:#eee; --accent:#4ad; }
  * { box-sizing:border-box; }
  body { margin:0; font-family:system-ui,-apple-system,"Segoe UI",Roboto,sans-serif; background:#0b0b0b; color:var(--ui-fg); }
  header { padding:16px 18px 8px; }
  h1 { margin:0 0 10px; font-size:20px; letter-spacing:.2px; }

  #controls {
    display:grid; gap:10px;
    grid-template-columns:repeat(auto-fit,minmax(240px,1fr));
    padding:0 18px 14px;
  }
  .card { background:var(--ui-bg); border:1px solid #1f1f1f; border-radius:10px; padding:14px; }
  .label { font-size:12px; color:#bbb; margin-bottom:6px; }
  input[type="number"]{
    width:100%; padding:8px 10px; border-radius:8px;
    border:1px solid #222; background:#181818; color:var(--ui-fg);
  }
  button{
    appearance:none; border:1px solid #233; border-radius:10px;
    padding:10px 12px; background:#17212b; color:#e9f4ff; cursor:pointer; font-weight:600;
  }
  button:hover{ filter:brightness(1.08); }
  button.secondary{ background:#1a1a1a; color:#ddd; border-color:#2a2a2a; }
  .row{ display:flex; gap:10px; flex-wrap:wrap; }
  .grow{ flex:1 1 auto; }

  #drop{
    border:2px dashed #2b2b2b; border-radius:12px; padding:18px; text-align:center;
    background:#121212; color:#ccc; transition:border-color .15s ease, background .15s ease; cursor:pointer;
  }
  #drop.drag{ border-color:var(--accent); background:#0e1620; color:#e3f2ff; }

  #previews{ display:grid; gap:12px; grid-template-columns:repeat(auto-fit,minmax(260px,1fr)); padding:0 18px 18px; }
  canvas.preview, img.preview{
    width:100%; background:#101010; border-radius:8px; border:1px solid #222; display:block;
  }
  .note{ color:#aaa; font-size:12px; margin-top:6px; }

  /* Print: only show the two worksheet images */
  @media print {
    body { background:#fff; }
    header, #controls, #previews { display:none !important; }
    #printWrap { display:block !important; }
    @page { size:auto; margin:12mm; }
  }
  #printWrap { display:none; }
  #printWrap img { width:100%; height:auto; display:block; }
  .page-break { break-before:page; page-break-before:always; }
</style>
</head>
<body>
<header>
  <h1>Pixel Math Worksheet Generator</h1>
</header>

<section id="controls">
  <div class="card">
    <div id="drop">
      <strong>Drop an image here</strong><br/>or click to choose
      <input id="file" type="file" accept="image/*" style="display:none" />
    </div>
    <div class="note">Tip: square/compact images work best for larger grids.</div>
  </div>

  <div class="card">
    <div class="row">
      <div class="grow">
        <div class="label">Number of pixels across</div>
        <input id="cols" type="number" min="4" max="96" step="1" value="24" />
      </div>
      <div class="grow">
        <div class="label">Number of pixels down</div>
        <input id="rows" type="number" min="4" max="96" step="1" value="24" />
      </div>
    </div>
    <div class="row">
      <div class="grow">
        <div class="label">Number of colors to use</div>
        <input id="kcolors" type="number" min="2" max="12" step="1" value="6" />
      </div>
    </div>
    
    <div class="card" id="answersCard" style="display:none">
      <div class="label">Answer Value for Each Color</div>
      <div id="answersContainer"></div>
    </div>
    
    <div class="row">
      <div class="grow">
        <div class="label">Font Size</div>
        <input id="fontScale" type="number" min="0.5" max="2.0" step="0.1" value="18.0" />
      </div>
    </div>

    <div class="row">
      <button id="btnPixelate" class="grow">Pixelate</button>
      <button id="btnGenerate" class="grow">Generate</button>
    </div>
    
    <div class="row" style="margin-top:4px;">
      <label style="display:flex;align-items:center;gap:6px;">
        <input id="includeAnswerKey" type="checkbox" checked />
        Include Answer Key in PDF
      </label>
    </div>
    
    <div class="row">
      <button id="btnSave" class="grow secondary">Save PDF</button>
    </div>
    <div class="note">“Save PDF” opens the print dialog; choose “Save as PDF”.</div>
  </div>

  <div class="card">
    <div class="label">Original (fit)</div>
    <canvas id="origCanvas" class="preview"></canvas>
  </div>

  <div class="card">
    <div class="label">Pixelated preview</div>
    <canvas id="pixCanvas" class="preview"></canvas>
    <div class="note">Click “Generate” to see worksheet and answer previews.</div>
  </div>

  <div class="card">
    <div class="label">Worksheet preview (used for PDF page 1)</div>
    <img id="worksheetPreview" class="preview" alt="worksheet preview"/>
  </div>

  <div class="card">
    <div class="label">Answer key preview (used for PDF page 2)</div>
    <img id="answerPreview" class="preview" alt="answer preview"/>
  </div>
</section>

<!-- Print-only images (2 pages) -->
<section id="printWrap">
  <img id="worksheetPrint" alt="worksheet print image"/>
  <img id="answerPrint" class="page-break" alt="answer print image"/>
</section>

<script>
(() => {
  // ---- State
  let img = new Image();
  let imgLoaded = false;

  const colsEl = document.getElementById('cols');
  const rowsEl = document.getElementById('rows');
  const kEl    = document.getElementById('kcolors');
  const includeAnswerKeyEl = document.getElementById('includeAnswerKey');

  const origCanvas = document.getElementById('origCanvas');
  const pixCanvas  = document.getElementById('pixCanvas');
  const octx = origCanvas.getContext('2d');
  const pctx = pixCanvas.getContext('2d');

  const worksheetPreviewImg = document.getElementById('worksheetPreview');
  const answerPreviewImg    = document.getElementById('answerPreview');
  const worksheetPrintImg   = document.getElementById('worksheetPrint');
  const answerPrintImg      = document.getElementById('answerPrint');

  let gridW=0, gridH=0;
  let cellColors = []; // raw downsampled
  let palette = [];    // [{r,g,b,hex}]
  let indices = [];    // palette index per cell
  let problems = [];   // problem text per cell

  let lastPageW = 1800;
  let lastPageH = 0;

  const clamp = (v,a,b) => Math.max(a, Math.min(b, v|0));
  const rgbToHex = (r,g,b) => '#' + [r,g,b].map(x => x.toString(16).padStart(2,'0')).join('');

  // ---- Draw original
  function drawOrigFit() {
    if (!imgLoaded) { octx.clearRect(0,0,origCanvas.width,origCanvas.height); return; }
    const maxW = 600;
    const scale = Math.min(1, maxW / img.width);
    origCanvas.width = Math.round(img.width * scale);
    origCanvas.height = Math.round(img.height * scale);
    octx.imageSmoothingEnabled = true;
    octx.clearRect(0,0,origCanvas.width,origCanvas.height);
    octx.drawImage(img, 0, 0, origCanvas.width, origCanvas.height);
  }

  // ---- Pixel sampling with averaging
  function sampleToGrid(w, h) {
    gridW = clamp(w, 4, 256);
    gridH = clamp(h, 4, 256);

    const tmp = document.createElement('canvas');
    tmp.width = img.width;
    tmp.height = img.height;
    const tctx = tmp.getContext('2d', { willReadFrequently: true });
    tctx.drawImage(img, 0, 0);

    const data = tctx.getImageData(0, 0, img.width, img.height).data;
    cellColors = new Array(gridW * gridH);

    const stepX = img.width / gridW;
    const stepY = img.height / gridH;

    for (let y = 0; y < gridH; y++) {
      for (let x = 0; x < gridW; x++) {
        let rSum = 0, gSum = 0, bSum = 0, count = 0;

        const startX = Math.floor(x * stepX);
        const startY = Math.floor(y * stepY);
        const endX = Math.min(Math.floor((x + 1) * stepX), img.width);
        const endY = Math.min(Math.floor((y + 1) * stepY), img.height);

        for (let iy = startY; iy < endY; iy++) {
          for (let ix = startX; ix < endX; ix++) {
            const idx = (iy * img.width + ix) * 4;
            rSum += data[idx];
            gSum += data[idx + 1];
            bSum += data[idx + 2];
            count++;
          }
        }

        cellColors[y * gridW + x] = {
          r: Math.round(rSum / count),
          g: Math.round(gSum / count),
          b: Math.round(bSum / count)
        };
      }
    }
  }

  // ---- K-means quantization
  function kmeansQuantize(K, maxIter = 15) {
    if (!cellColors.length) return;
    const pixels = cellColors.map(p => [p.r, p.g, p.b]);

    const centroids = [];
    const usedIndices = new Set();
    while (centroids.length < K) {
      const idx = Math.floor(Math.random() * pixels.length);
      if (!usedIndices.has(idx)) { centroids.push([...pixels[idx]]); usedIndices.add(idx); }
    }

    let assignments = new Array(pixels.length).fill(0);

    for (let iter=0; iter<maxIter; iter++) {
      for (let i=0;i<pixels.length;i++) {
        let minD=Infinity, best=0;
        for (let k=0;k<K;k++) {
          const dr=pixels[i][0]-centroids[k][0];
          const dg=pixels[i][1]-centroids[k][1];
          const db=pixels[i][2]-centroids[k][2];
          const d=dr*dr+dg*dg+db*db;
          if (d<minD){minD=d;best=k;}
        }
        assignments[i]=best;
      }

      const sums = Array(K).fill(0).map(()=>[0,0,0,0]);
      for (let i=0;i<pixels.length;i++){
        const k=assignments[i];
        sums[k][0]+=pixels[i][0];
        sums[k][1]+=pixels[i][1];
        sums[k][2]+=pixels[i][2];
        sums[k][3]+=1;
      }
      for (let k=0;k<K;k++){
        if (sums[k][3]>0){
          centroids[k][0]=sums[k][0]/sums[k][3];
          centroids[k][1]=sums[k][1]/sums[k][3];
          centroids[k][2]=sums[k][2]/sums[k][3];
        }
      }
    }

    palette = centroids.map(c=>{
      const r=Math.round(c[0]), g=Math.round(c[1]), b=Math.round(c[2]);
      return {r,g,b,hex:rgbToHex(r,g,b), lum:0.2126*r+0.7152*g+0.0722*b};
    }).sort((a,b)=>a.lum-b.lum);

    indices = pixels.map(pix=>{
      let best=0, minD=Infinity;
      for (let k=0;k<palette.length;k++){
        const dr=pix[0]-palette[k].r;
        const dg=pix[1]-palette[k].g;
        const db=pix[2]-palette[k].b;
        const d=dr*dr+dg*dg+db*db;
        if(d<minD){minD=d;best=k;}
      }
      return best;
    });
  }

  // ---- File input / drop
  const drop = document.getElementById('drop');
  const file = document.getElementById('file');
  drop.addEventListener('click', ()=> file.click());

  function handleFiles(files) {
    if (!files || !files[0]) return;
    const url = URL.createObjectURL(files[0]);
    const imgNew = new Image();
    imgNew.onload = () => { img = imgNew; imgLoaded = true; drawOrigFit(); URL.revokeObjectURL(url); };
    imgNew.onerror = () => alert('Could not load that image.');
    imgNew.src = url;
  }
  drop.addEventListener('dragover', e => { e.preventDefault(); drop.classList.add('drag'); });
  drop.addEventListener('dragleave', ()=> drop.classList.remove('drag'));
  drop.addEventListener('drop', e => { e.preventDefault(); drop.classList.remove('drag'); handleFiles(e.dataTransfer.files); });
  file.addEventListener('change', e => handleFiles(e.target.files));

  // ---- Buttons
  document.getElementById('btnPixelate').addEventListener('click', ()=>{
    if(!imgLoaded){alert('Please upload an image first.');return;}
    const W=parseInt(colsEl.value,10)||24;
    const H=parseInt(rowsEl.value,10)||24;
    const K=parseInt(kEl.value,10)||6;
    sampleToGrid(W,H);
    kmeansQuantize(K);
    // drawPixelatedPreview(); -- add your drawPixelatedPreview function here
  });

})();
</script>
</body>
</html>
