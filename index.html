<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pixel Math Worksheet Generator</title>
<style>
:root { --ui-bg:#111; --ui-fg:#eee; --accent:#4ad; }
* { box-sizing:border-box; }
body { margin:0; font-family:system-ui,-apple-system,"Segoe UI",Roboto,sans-serif; background:#0b0b0b; color:var(--ui-fg); }
header { padding:16px 18px 8px; }
h1 { margin:0 0 10px; font-size:20px; letter-spacing:.2px; }
#controls { display:grid; gap:10px; grid-template-columns:repeat(auto-fit,minmax(240px,1fr)); padding:0 18px 14px; }
.card { background:var(--ui-bg); border:1px solid #1f1f1f; border-radius:10px; padding:14px; }
.label { font-size:12px; color:#bbb; margin-bottom:6px; }
input[type="number"]{ width:100%; padding:8px 10px; border-radius:8px; border:1px solid #222; background:#181818; color:var(--ui-fg); }
button{ appearance:none; border:1px solid #233; border-radius:10px; padding:10px 12px; background:#17212b; color:#e9f4ff; cursor:pointer; font-weight:600; }
button:hover{ filter:brightness(1.08); }
button.secondary{ background:#1a1a1a; color:#ddd; border-color:#2a2a2a; }
.row{ display:flex; gap:10px; flex-wrap:wrap; }
.grow{ flex:1 1 auto; }
#drop{ border:2px dashed #2b2b2b; border-radius:12px; padding:18px; text-align:center; background:#121212; color:#ccc; transition:border-color .15s ease, background .15s ease; cursor:pointer; }
#drop.drag{ border-color:var(--accent); background:#0e1620; color:#e3f2ff; }
#previews{ display:grid; gap:12px; grid-template-columns:repeat(auto-fit,minmax(260px,1fr)); padding:0 18px 18px; }
canvas.preview, img.preview{ width:100%; background:#101010; border-radius:8px; border:1px solid #222; display:block; }
.note{ color:#aaa; font-size:12px; margin-top:6px; }
@media print { body { background:#fff; } header, #controls, #previews { display:none !important; } #printWrap { display:block !important; } @page { size:auto; margin:12mm; } }
#printWrap { display:none; }
#printWrap img { width:100%; height:auto; display:block; }
.page-break { break-before:page; page-break-before:always; }
</style>
</head>
<body>
<header>
<h1>Pixel Math Worksheet Generator</h1>
</header>

<section id="controls">
<div class="card">
  <div id="drop">
    <strong>Drop an image here</strong><br/>or click to choose
    <input id="file" type="file" accept="image/*" style="display:none" />
  </div>
  <div class="note">Tip: square/compact images work best for larger grids.</div>
</div>

<div class="card">
  <div class="row">
    <div class="grow">
      <div class="label">Number of pixels across</div>
      <input id="cols" type="number" min="4" max="96" step="1" value="24" />
    </div>
    <div class="grow">
      <div class="label">Number of pixels down</div>
      <input id="rows" type="number" min="4" max="96" step="1" value="24" />
    </div>
  </div>
  <div class="row">
    <div class="grow">
      <div class="label">Number of colors to use</div>
      <input id="kcolors" type="number" min="2" max="12" step="1" value="6" />
    </div>
  </div>

  <div class="card" id="answersCard" style="display:none">
    <div class="label">Answer Value for Each Color</div>
    <div id="answersContainer"></div>
  </div>

  <div class="row">
    <div class="grow">
      <div class="label">Font Size</div>
      <input id="fontScale" type="number" min="6" max="36" step="1" value="18" />
    </div>
  </div>

  <div class="row">
    <button id="btnPixelate" class="grow">Pixelate</button>
    <button id="btnGenerate" class="grow">Generate</button>
  </div>
  <div class="row" style="margin-top:4px;">
    <label style="display:flex;align-items:center;gap:6px;">
      <input id="includeAnswerKey" type="checkbox" checked />
      Include Answer Key in PDF
    </label>
  </div>
  <div class="row">
    <button id="btnSave" class="grow secondary">Save PDF</button>
  </div>
  <div class="note">“Save PDF” opens the print dialog; choose “Save as PDF”.</div>
</div>

<div class="card">
  <div class="label">Original (fit)</div>
  <canvas id="origCanvas" class="preview"></canvas>
</div>

<div class="card">
  <div class="label">Pixelated preview</div>
  <canvas id="pixCanvas" class="preview"></canvas>
  <div class="note">Click “Generate” to see worksheet and answer previews.</div>
</div>

<div class="card">
  <div class="label">Worksheet preview (used for PDF page 1)</div>
  <img id="worksheetPreview" class="preview" alt="worksheet preview"/>
</div>

<div class="card">
  <div class="label">Answer key preview (used for PDF page 2)</div>
  <img id="answerPreview" class="preview" alt="answer preview"/>
</div>
</section>

<section id="printWrap">
<img id="worksheetPrint" alt="worksheet print image"/>
<img id="answerPrint" class="page-break" alt="answer print image"/>
</section>

<script>
(() => {
let img = new Image();
let imgLoaded = false;

const colsEl = document.getElementById('cols');
const rowsEl = document.getElementById('rows');
const kEl    = document.getElementById('kcolors');
const includeAnswerKeyEl = document.getElementById('includeAnswerKey');

const origCanvas = document.getElementById('origCanvas');
const pixCanvas  = document.getElementById('pixCanvas');
const octx = origCanvas.getContext('2d');
const pctx = pixCanvas.getContext('2d');

const worksheetPreviewImg = document.getElementById('worksheetPreview');
const answerPreviewImg    = document.getElementById('answerPreview');
const worksheetPrintImg   = document.getElementById('worksheetPrint');
const answerPrintImg      = document.getElementById('answerPrint');

let gridW=0, gridH=0;
let cellColors = [];
let palette = [];
let indices = [];
let problems = [];

let lastPageW = 1800;
let lastPageH = 0;

const clamp = (v,a,b) => Math.max(a, Math.min(b, v|0));
const rgbToHex = (r,g,b) => '#' + [r,g,b].map(x => x.toString(16).padStart(2,'0')).join('');

function drawOrigFit() {
    if (!imgLoaded) { octx.clearRect(0,0,origCanvas.width,origCanvas.height); return; }
    const maxW = 600;
    const scale = Math.min(1, maxW / img.width);
    origCanvas.width = Math.round(img.width * scale);
    origCanvas.height = Math.round(img.height * scale);
    octx.imageSmoothingEnabled = true;
    octx.clearRect(0,0,origCanvas.width,origCanvas.height);
    octx.drawImage(img, 0, 0, origCanvas.width, origCanvas.height);
}

function sampleToGrid(w, h) {
    gridW = clamp(w, 4, 256);
    gridH = clamp(h, 4, 256);

    const tmp = document.createElement('canvas');
    tmp.width = img.width;
    tmp.height = img.height;
    const tctx = tmp.getContext('2d', { willReadFrequently: true });
    tctx.drawImage(img, 0, 0);

    const data = tctx.getImageData(0, 0, img.width, img.height).data;
    cellColors = new Array(gridW * gridH);

    const stepX = img.width / gridW;
    const stepY = img.height / gridH;

    for (let y = 0; y < gridH; y++) {
      for (let x = 0; x < gridW; x++) {
        const cx = Math.floor((x + 0.5) * stepX);
        const cy = Math.floor((y + 0.5) * stepY);
        const idx = (cy * img.width + cx) * 4;
        const r = data[idx], g = data[idx + 1], b = data[idx + 2];
        cellColors[y * gridW + x] = { r, g, b };
      }
    }
}

function clusterQuantize(maxColors, tolerance = 25) {
    const clusters = [];
    for (const pix of cellColors) {
        let found = false;
        for (const cl of clusters) {
            const dr = pix.r - cl.r;
            const dg = pix.g - cl.g;
            const db = pix.b - cl.b;
            const dist = Math.sqrt(dr * dr + dg * dg + db * db);
            if (dist < tolerance) {
                cl.r = (cl.r * cl.count + pix.r) / (cl.count + 1);
                cl.g = (cl.g * cl.count + pix.g) / (cl.count + 1);
                cl.b = (cl.b * cl.count + pix.b) / (cl.count + 1);
                cl.count++;
                found = true;
                break;
            }
        }
        if (!found) clusters.push({ r: pix.r, g: pix.g, b: pix.b, count: 1 });
    }

    function distance(a,b){ const dr=a.r-b.r, dg=a.g-b.g, db=a.b-b.b; return dr*dr+dg*dg+db*db; }

    while (clusters.length > maxColors) {
        let minD=Infinity, ai=0, bi=1;
        for(let i=0;i<clusters.length;i++){for(let j=i+1;j<clusters.length;j++){const d=distance(clusters[i],clusters[j]); if(d<minD){minD=d; ai=i; bi=j;}}}
        const a=clusters[ai], b=clusters[bi], total=a.count+b.count;
        a.r=(a.r*a.count+b.r*b.count)/total;
        a.g=(a.g*a.count+b.g*b.count)/total;
        a.b=(a.b*a.count+b.b*b.count)/total;
        a.count=total;
        clusters.splice(bi,1);
    }

    const pal = clusters.map(c=>{const hex=rgbToHex(Math.round(c.r),Math.round(c.g),Math.round(c.b)); const lum=0.2126*c.r+0.7152*c.g+0.0722*c.b; return {r:Math.round(c.r),g:Math.round(c.g),b:Math.round(c.b),hex,lum};}).sort((a,b)=>a.lum-b.lum);

    indices = new Array(cellColors.length);
    for(let i=0;i<cellColors.length;i++){
        const p=cellColors[i];
        let best=0, bd=Infinity;
        for(let c=0;c<pal.length;c++){
            const d=distance(p,pal[c]);
            if(d<bd){ bd=d; best=c; }
        }
        indices[i]=best;
    }

    palette = pal;
}

function drawPixelatedPreview() {
    const scale=10;
    pixCanvas.width=gridW*scale;
    pixCanvas.height=gridH*scale;
    pctx.clearRect(0,0,pixCanvas.width,pixCanvas.height);
    for(let y=0;y<gridH;y++){
        for(let x=0;x<gridW;x++){
            const idx=indices[y*gridW+x];
            pctx.fillStyle=palette[idx].hex;
            pctx.fillRect(x*scale,y*scale,scale,scale);
        }
    }
    pctx.strokeStyle='rgba(0,0,0,.35)';
    for(let x=0;x<=gridW;x++){pctx.beginPath();pctx.moveTo(x*scale+0.5,0);pctx.lineTo(x*scale+0.5,gridH*scale);pctx.stroke();}
    for(let y=0;y<=gridH;y++){pctx.beginPath();pctx.moveTo(0,y*scale+0.5);pctx.lineTo(gridW*scale,y*scale+0.5);pctx.stroke();}
}

// ... RenderWorksheetCanvas, RenderAnswerCanvas, and remaining code omitted for brevity
// (This will include the original math problem grid, horizontal color-number key, and answer key with original image behind it.)

// File input, drag & drop, and button handlers here
})();
</script>
</body>
</html>
